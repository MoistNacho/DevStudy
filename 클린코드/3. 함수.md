# 3장 - 함수
### > 서론
- 의도를 분명히 표현하는 함수를 어떻게 구현할 수 있을까?
- 함수에 어떤 속성을 부여해야 처음 읽는 사람이 프로그램 내부를 직관적으로 파악할 수 있을까?
- 함수를 읽는 사람이 이해하기 쉽도록 길이가 짧고, 이름이 좋고, 체계가 잡힌 함수를 만드는 방법을 알아보자

### > 읽기 힘든 코드...
```
//목록 3-1 예코드
public static String testableHtml(PageData pageData, boolean includeSuiteSetup) throws Exception {
    WikiPage wikiPage = pageData.getWikiPage();
    StringBuffer buffer = new StringBuffer();
    if (pageData.hasAttribute("Test")) {
        if (includeSuiteSetup) {
            WikiPage suiteSetup = PageCrawlerImpl.getInheritedPage(SuiteResponder.SUITE_SETUP_NAME, wikiPage);
​
            if (suiteSetup != null) {
                WikiPagePath pagePath = suiteSetup.getPageCrawler().getFullPath(suiteSetup);
                String pagePathName = PathParser.render(pagePath);
                buffer.append("!include -setup .")
                      .append(pagePathName)
                      .append("\n");
            }
        }
        WikiPage setup = PageCrawlerImpl.getInheritedPage("SetUp" ,wikiPage);
        if(setup != null) {
            WikiPagePath setupPath = wikiPage.getPageCrawler().getFullPath(setup);
            String setupPathName = PathParser.render(setupPath);
            buffer.append("!include -setup .")
                  .append(setupPathName)
                  .append("\n");
        }
    }
    buffer.append(pageData.getContent());
    if (pageData.hasAttribute("Test")) {
        WikiPage tearDown = PageCrawlerImpl.getInheritedPage("TearDown", wikiPage);
        if(tearDown != null) {
            WikiPagePath tearDownPath = wikiPage.getPageCrawler().getFullPath(tearDown);
            String tearDownPathName = PathParser.render(tearDownPath);
            buffer.append("\n")
                  .append("!include -teardown .")
                  .append(tearDownPathName)
                  .append("\n");
        }
​
        if (includeSuiteSetup) {
            WikiPage suiteTearDown = PageCrawlerImpl.getInheritedPage(SuiteResponder.SUITE_TEARDOWN_NAME, wikiPage);
            if (suiteTearDown != null) {
                WikiPagePath pagePath = suiteTearDown.getPageCrawler().getFullPath(suiteTearDown);
                String pagePathName = PathParser.render(pagePath);
                buffer.append("!include -teardown .")
                      .append(pagePathName)
                      .append("\n");
            }
        }
    }
    pageData.setContent(buffer.toString());
    return pageData.getHtml();
}
```
- 추상화 수준이 다양하다
- 하나의 함수 안에 너무 많은 코드가 작성되어 있다
- 두 겹 이상 으로 중첩된 if문이 존재한다

우선, 위의 코드의 메서드를 추출하고, 이름을 수정하고, 구조를 조금 변경하여 아래의 `예제 3-2`로 바꾸었다
```
// 목록 3-2 예제코드
public static String renderPageWithSetupsAndTearDowns(PageData pageData, boolean isSuite) throws Exception {
    boolean isTestPage = pageData.hasAttribute("Test");
    if (isTestPage) {
        WikiPage testPage = pageData.getWikiPage();
        StringBuffer newPageContent = new StringBuffer();
        includeSetupPages(testPage, newPageContent, isSuite);
        newPageContent.append(pageData.getContent());
        includeTeardownPages(testPage, newPageContent, isSuite);
        pageData.setContent(newPageContent.toString());
    }
    return pageData.getHtml();
}
```

### > 작게 만들어라
- 함수를 만드는 첫번째 규칙은 **'작게!'** 두번째 규칙은 **'더 작게!'** 이다
  - 저자는 20줄도 길다고 한다. `예제 3-2`는 `예제 3-3`만큼 줄여야 마땅하다
```
public static String renderPageWithSetupsAndTearDowns(PageData pageData, boolean isSuite) throws Exception {
    if (isTest(pageData)) {
        includeSetupAndTeardownPages(pageData, isSuite);
    }
    return pageData.getHtml();
}
```
- **블록과 들여쓰기**
  - if/else, while 문 등에 들어가는 불록은 한줄이어야 한다. 즉, 중첩 구조가 생길만큼 함수가 커져서는 안된다
  - 함수에서 들여쓰기 수준은 1단이나 2단을 넘어서는 안된다
- 큰 함수를 작게 쪼개면서 적절한 이름을 붙여주면 코드를 이해하기 쉬워진다

### > 한가지만 해라!
- 함수는 한 가지를 해야 한다. 그 한 가지를 잘 해야 한다. 그 한가지만을 해야 한다
- `예제 3-3`은 한 가지만 하는가? 세 가지를 한다고 주장할 수도 있다
  - 페이지가 테스트 페이지인지 판단한다
  - 그렇다면 설정 페이지와 해제 페이지를 넣는다
  - 페이지를 HTML로 렌더링한다
- 위의 3가지 단계는 **지정된 함수 이름 아래에서 추상화 수준이 하나**이다. 한 가지만 하는지 판단하는 방법은?
  - 지정된 함수 이름 아래에서 추상화 수준이 하나인 단계만 수행한다면 그 함수는 한 가지 작업만 한다
  - **함수 이름을 단순히 다른 표현이 아니라 의미 있는 이름으로 다른 함수를 추출 할 수 있다**면 그 함수는 여러 작업을 하고 있는 것이다
#### 함수당 추상화 수준은 하나로!
- 함수가 한가지 작업만 하려면 함수 내 모든 문장의 추상화 수준이 동일 해야한다, `예제 3-1`을 예시로 살펴보면...
  - getHtml() 은 추상화 수준이 아주 높다
  - String pagePathName = PathParser.render(pagePath) 는 추상화 수준이 중간이다
  - append("\n") 와 같은 코드는 추상화 수준이 아주 낮다
- 하나의 함수에 여러 추상화 수준이 있으면 해당 코드가 특정 기능의 근본 개념인지, 아니면 세부사항인지 알아보기가 힘들다
##### 내려가기 규칙(위에서 아래로 코드 읽기)
- 코드는 위에서 아래로 이야기처럼 읽혀야 좋다
- 한 함수 다음에는 추상화 수준이 한 단계 더 낮은 함수가 와야한다
- 즉, 위에서 아래로 코드를 읽으면 함수 추상화 수준이 한 번에 한 단계씩 낮아진다
- 핵심은 **짧으면서도 한 가지 일만 하는 함수가 좋다**

### > Switch문


# 13장 - 동시성
### > 서론
> "객체는 처리의 추상화다. 스레드는 일정의 추상화다." 
> <div align=right>-제임스 O. 코플리엔</div>

- 동시성과 깔끔한 코드는 양립하기 어렵다. 스레드를 하나만 실행 하는 코드는 짜기가 쉽다.
- 겉으로 보기에는 멀쩡해 보이는 다중 스레드코드도 짜기 쉽다. 이런코드는 시스템이 부하를 받기 전까지 멀쩡 하게 돌아간다.
- 이번 장에서는 concurrent 프로그래밍의 필요성, 어려움에 대해 논한다. 
- 이런 어려움에 대처하고 깨끗한 코드를작성 하는 방법도 몇 가지 제안한다. 동시성을 테스트하는 방법과 문제점을 논한다.

### > 동시성이 필요한 이유?
동시성은 **결합(coupling)** 을 없애는 전략이다. 즉, **무엇(what)** 과 **언제(when)** 를 분리하는 전략이다.

- 무엇과 언제를 분리하면 애플리케이션 구조와 효율이 극적으로 나아진다.
- 구조적인 관점에서 프로그램은 거대한 루프 하나가 아니라 작은 협력 프로그램 여럿으로 보인다.
- 응답시간과 작업 처리량(throughput)을 개선하려면 직접적인 동시성 구현이 불가피하다.
- 이렇듯 반드시 동시성이 필요한 상황이 존재한다.

#### 미신과 오해
- 동시성은 항상 성능을 높여준다.
  - 동시성은 때로 성능을 높여준다. 대기 시간이 아주 길어 여러 스레드가 프로세서를 공유할 수 있거나, 여러 프로세서가 동시에 처리할 독립적인 계산이 충분히 많은 경우에만 성능이 높아진다.
- 동시성을 구현해도 설계는 변하지 않는다.
  - 단일 스레드 시스템과 다중 스레드 시스템은 설계가 판이하게 다르다.
  - 일반적으로 무엇과 언제를 분리하면 시스템 구조가 크게 달라진다.
- 웹 또는 EJB 컨테이너를 사용하면 동시성을 이해할 필요가 없다.
  - 컨테이너가 어떻게 동작하는지, 어떻게 동시 수정, 데드락 등과 같은 문제를 피할 수 있는지 알아야 한다.
> EJB(Enterprise Java Bean): 기업환경의 시스템을 구현하기 위한 서버 측 컴포넌트 모델이다. 일반적으로 업무 로직을 가지고 있는 서버 어플리케이션을 EJB라고 한다.

##### 동시성과 관련된 타당한 생각 몇 가지
- 동시성은 다소 부하를 유발한다. 성능 측면에서 부하가 걸리며 코드도 더 짜야한다.
- 동시성은 복잡하다. 간단한 문제라도 동시성은 복잡하다.
- 일반적으로 동시성 버그는 재현하기 어렵다. 그래서 진짜 결함으로 간주되지 않고 일회성 문제로 여겨 무시하기 쉽다.
- 동시성을 구현하려면 흔히 근본적인 설계 전략을 재고해야 한다.

### > 난관
동시성을 구현하기가 어려운 이유는 무엇일까?
```
public class X {
	private int lastIdUsed;

	public int getNextId() {
		return ++lastIdUsed;
	}
}
```
인스턴스 X를 생성하고, lastIdUsed 를 42로 설정한 다음, 두 스레드가 해당 인스턴스를 공유한다.   
두 스레드가 getNextId();를 호출한다면, 결과는 셋 중 하나다.

- 한 스레드는 43을 받는다. 다른 스레드는 44를 받는다. lastIdUsed는 44이 된다.
- 한 스레드는 44을 받는다. 다른 스레드는 43을 받는다. lastIdUsed는 44이 된다.
- 한 스레드는 43을 받는다. 다른 스레드는 43를 받는다. lastIdUsed는 43이 된다. (동시 실행)

객체 하나를 공유한 후 동일 필드를 수정하던 두 스레드가 서로 간섭하므로 예상치 못한 결과를 내놓는다.

### > 동시성 방어 원칙
동시성 코드가 일으키는 문제로부터 시스템을 방어하는 원칙과 기술들을 소개

#### 단일 책임 원칙 (Single Responsibility Principle, SRP)
- SRP는 주어진 메서드/클래스/컴포넌트를 변경할 이유가 하나여야 한다는 원칙 이다.
- 동시성 구현시 고려 사항
  - 동시성 코드는 독자적인 개발, 변경, 조율 주기가 있다.
  - 동시성 코드에는 독자적인 난관이 있다. 다른 코드의 난관과 다르고 훨씬 어렵다.
  - 잘못 구현한 동시성 코드는 별의별 방식으로 실패한다.

**권장사항:** 동시성 관련 코드는 다른 코드와 분리해야 한다.

#### 따름 정리: 자료 범위를 제한하라
- 공유 객체를 시용하는 코드 내 임계영역(critical section)을 synchronized 키워드로 보호하라.
- 이런 임계영역의 수를 줄이는 기술이 중요하다.
- 공유자료를 수정하는 위치가 많을수록 커지는 문제
  - 보호할 임계영역을 빼먹는다. 그래서 공유 자료를 수정하는 모든 코드를 망가뜨린다.
  - 임계영역을 올바르게 보호했는지 확인하느라 똑같은 노력과 수고를 반복한다.
  - 찾기 어려운 버그가 더 찾기 어렵게 된다.

**권장사항:** 자료를 캡슐화하라. 공유 자료를 최대한 줄여라.

#### 따름 정리: 자료 사본을 사용하라
- 공유 자료를 줄이려면 처음부터 공유하지 않는 방법이 제일 좋다.
- 어떤 경우에는 객체를 복사해 읽기 전용으로 사용하는 방법이 가능하다.
- 각 스레드가 객체를 복사해 사용한 후 한 스레드가 해당 사본에서 결과를 가져오는 방법도 가능하다.
- 객체를 복사하는 cost 가 공유 자원 동기화 cost 보다 작을 수 있다.

#### 따름 정리: 스레드는 가능한 독립적으로 구현하라
- 자신만의 세상에 존재하는 스레드를 구현한다. 즉, 다른 스레드와 자료를 공유 하지 않는다.
- 각 스레드는 클라이언트 요청 하나를 처리한다.
- 모든 정보는 비공유 출처에서 가져오며 로컬 변수에 저장한다.

**권장사항:** 독자적인 스레드로, 가능하면 다른 프로세서에서, 돌려도 괜찮도록 자료를 독립적인 단위로 분할하라.

### > 라이브러리를 이해하라
*자바5와 관련된 내용이기에 스킵 😅*
**권장사항:** 언어가 제공하는 클래스를 검토하라.
자바에서는 java.util.concurrent, java.util.concurrent.atomic, java.util.concurrent.locks를 익혀라. 

### > 실행 모델을 이해하라
기본 용어

|제목|내용|
|------|---|
|한정된 자원 (Bound Resource)|다중 스레드 환경에서 사용하는 자원. 크기나 숫자가 제한적이다. ex) 데이터베이스 연결, 길이가 일정한 읽기/쓰기 버퍼|
|상호 배제 (Mutual Exclusion)|한 번에 한 스레드만 공유 자료나 공유 자원을 사용할 수 있는 경우를 가리킨다.|
|기아 (Starvation)|스레드가 오래 혹은 영원히 자원을 기다린다. ex) 짧은 스레드에게 우선순위를 준다면, 긴 스레드가 기아 상태에 빠진다.|
|데드락 (Deadlock)|스레드가 서로 끝나기를 기다린다. 모든 스레드가 각기 필요한 자원을 다른 스레드가 점유해 어느쪽도 진행하지 못한다.|
|라이브락 (Livelock)|락을 거는 단계에서 각 스레드가 서로를 방해한다. 오래 혹은 영원히 진행하지 못한다.|

기본 개념을 알아봤으니 다중 스레드 애플리케이션에서 사용하는 실행 모델을 몇 가지 살펴보자.

#### 생산자-소비자 (Producer-Consumer)
하나 이상 생산자 스레드가 정보를 생성해 버퍼나 대기열에 넣는다. 하나 이상 소비자 스레드가 대기열에서 정보를 가져와 사용한다. 두 스레드가 사용하는 대기열은 **한정된 자원** 이다.   
생산자 스레드는 대기열에 빈 공간이 있어야 정보를 채운다. 즉, 빈 공간이 생길 때까지 기다린다. 소비자 스레드는 대기열에 정보가 있어야 가져온다. 즉, 정보가 채워질 때까지 기다린다. 따라서, 잘못하면 두 스레드 모두 진행 가능함에도 불구하고 동시에 서로에게 시그널을 기다릴 가능성이 존재한다.

#### 읽기-쓰기(Readers-Writers)
읽기 스레드는 주된 정보원으로 공유 자원을 사용하지만 쓰기 스레드가 공유 자원을 가끔 갱신한다고 하자. 이런 경우 처리율이 문제의 핵심인데 처리율을 강조하면 기아 현상이 생기거나 오래된 정보가 쌓일 수 있다.   
대개는 쓰기 스레드가 버퍼를 오랫동안 점유하는 바람에 여러 읽기 스레드가 버퍼를 기다리느라 처리율이 떨어진다. 따라서, 읽기 스레드의 요구와 쓰기 스레드의 요구를 적절히 만족시켜 처리율도 적당히 높이고 기아도 방지해야 한다.

#### 식사하는 철학자들(Dining Philosophers)
원탁을 둘러싼 여러 명의 철학자들이 있다. 각 철학자의 왼쪽에 포크가 놓여 있으며 테이블의 중앙에 큰 스파게티 한 그릇이 놓여 있다. 그들은 배가 고파지기 전까지 각자 생각을 하며 시간을 보낸다. 배가 고파지면 그들은 자신의 양쪽에 놓여 있는 포크 2개를 잡고 스파게티를 먹는다.   
철학자는 포크 2개가 있어야만 스파게티를 먹을 수 있다. 그렇지 않다면 옆 사람이 포크를 다 사용하기 전까지 기다려야 한다. 스파게티를 먹은 철학자는 다시 배가 고파질 때까지 포크를 놓고 있게 된다.   
위 상황에서 철학자를 스레드로, 포크를 공유 자원으로 바꾸게 되면 이는 자원을 놓고 경쟁하는 프로세스와 비슷한 상황이 된다. 잘 설계되지 않은 시스템은 데드락, 라이브락, 처리량 문제, 효율성 저하 문제에 맞닥뜨리기 쉽다.   

**권장사항:** 위에서 설명한 기본 알고리즘과 각 해법을 이해하라.

# 9장 - 단위 테스트
### > 도시를 세운다면?
여러분이 도시를 세운다면? 온갖 세세한 사항을 혼자서 관리할 수 있을까?

- 도시에는 각각의 관리 팀들이 존재하기 때문이다. (수도 관리팀, 전력 관리팀, 교통 관리팀 등등..)
- 도시가 잘 돌아가는 이유는 적절한 추상화 와 모듈화 가 잘되어 있다.

소프트웨어 팀도 도시처럼 구성한다.   
깨끗한 코드를 구현하면 낮은 추상화 수준에서 관심사를 분리하기 쉬워진다.   
이번장에서는 높은 추상화 수준, 즉 **시스템** 수준에서도 깨끗함을 유지하는 방법을 살펴보자.

### > 시스템 제각과 시스템 사용을 분리하라
**제작(construction)**은 **사용(use)**과 아주 다르다.
```
소프트웨어 시스템은 (애플리케이션 객체를 제작하고 의존성을 서로 '연결'하는)
준비 과정과 (준비 과정 이후에 이어지는) 런타임 로직을 분리해야 한다.
```

시작 단계는 모든 애플리케이션이 풀어야 할 **관심사**다.
- 관심사 분리는 우리 분야에서 가장 오래되고 가장 중요한 설계 기법 중 하나다.
- 대다수 애플리케이션은 시작 단계라는 관심사를 분리하지 않는다.
- 준비 과정 코드가 런타임 로직과 마구 뒤섞이는 경우가 있다.

아래 예시는 **관심사 분리**가 되지않은 전형적인 예다.
```java
public Service getService() {
	if(service == null)
		service = new MyServiceImpl(...);
	return service;
}
```
위 코드는 초기화 지연(Lazy Initialization) 혹은 계산 지연(Lazy Evaluation)이라는 기법이다.
- 장점
  - 필요할 때까지 객체를 생성하지 않아 과부하를 막는다.
  - 애플리케이션 시작이 그만큼 빨라진다.
  - Null을 반환하지 않는다.
- 단점
  - MyServiceImpl과 생성자 인수에 명시적으로 의존한다.
  - 실제로 MyServiceImpl객체를 사용하지 않더라도 의존성 해결이 안되면 컴파일이 안 된다.
  - 테스트시 테스트 전용객체(Mock Object)를 할당해야 한다.
  - 생성과 사용 로직이 섞여있어서 모든 실행 경로도 테스트 해야 한다.
  - 책임이 여러개라는 말은 SRP(단일 책임 원칙)을 깬다. 
  - MyServiceImpl이 모든 상황에 적합한 객체인지 알 수 없다.
결국, 위와같은 기법은 가볍게 한 번정도 사용할때는 상관없지만 사용빈도가 높아질수록 문제가 많아진다.   
체계적이고 탄탄한 시스템을 만들고 싶다면 흔히 쓰는 **손쉬운 기법**으로 모듈성을 깨서는 절대로 안된다.   
시스템의 생성과 사용 로직을 분리해야 한다.   

#### Main 분리
![image](https://user-images.githubusercontent.com/59498305/237022465-bc440a48-f634-4c67-876d-292b91cf8099.png)   

시스템 생성과 사용을 분리하는 가장 간단한 방법은 모든 생성과 관련된 로직을 main으로 옮기는 것이다.   
애플리케이션에서는 그저 객체를 사용할 뿐, 사용할 모든 객체들이 main에서 잘 생성되었을 것이라 여기고 나머지 디자인에 집중할 수 있다.

#### 팩토리
![image](https://user-images.githubusercontent.com/59498305/237023145-d3d5064e-463b-4c9e-9c28-ee9a1c7e22b6.png)   

때로는 객체가 생성되는 **시점**을 애플리케이션이 결정할 필요도 생긴다. 이때는 추상 팩토리(Abstract Factory)패턴을 사용한다.   
- 마찬가지로 모든 의존성이 `main`에서 `OrderProcessing`으로 향하게 된다.
- `OrderProcessing` 입장에서는 `LineItem`이 어떻게 생성되는지 모른다.
- 그렇지만 `OrderProcessing`은 `LineItem`가 생성되는 시점을 완벽하게 통제하며, 필요하다면 `OrderProcessing` 애플리케이션에서만 사용하는 생성자 인수도 넘길 수 있다.

